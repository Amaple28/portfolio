{"version":3,"file":"superstruct.modern.mjs","sources":["../src/superstruct.ts"],"sourcesContent":["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport { FieldError, FieldValues, Resolver } from 'react-hook-form';\nimport { Infer, Struct, StructError, validate } from 'superstruct';\n\nfunction parseErrorSchema(error: StructError) {\n  return error.failures().reduce<Record<string, FieldError>>(\n    (previous, error) =>\n      (previous[error.path.join('.')] = {\n        message: error.message,\n        type: error.type,\n      }) && previous,\n    {},\n  );\n}\n\nexport function superstructResolver<Input extends FieldValues, Context, Output>(\n  schema: Struct<Input, any>,\n  schemaOptions?: Parameters<typeof validate>[2],\n  resolverOptions?: {\n    raw?: false;\n  },\n): Resolver<Input, Context, Infer<typeof schema>>;\n\nexport function superstructResolver<Input extends FieldValues, Context, Output>(\n  schema: Struct<Input, any>,\n  schemaOptions: Parameters<typeof validate>[2] | undefined,\n  resolverOptions: {\n    raw: true;\n  },\n): Resolver<Input, Context, Input>;\n\n/**\n * Creates a resolver for react-hook-form using Superstruct schema validation\n * @param {Struct<TFieldValues, any>} schema - The Superstruct schema to validate against\n * @param {Parameters<typeof validate>[2]} [schemaOptions] - Optional Superstruct validation options\n * @param {Object} resolverOptions - Additional resolver configuration\n * @param {boolean} [resolverOptions.raw=false] - If true, returns raw values rather than validated results\n * @returns {Resolver<Infer<typeof schema>>} A resolver function compatible with react-hook-form\n * @example\n * const schema = struct({\n *   name: string(),\n *   age: number()\n * });\n *\n * useForm({\n *   resolver: superstructResolver(schema)\n * });\n */\nexport function superstructResolver<Input extends FieldValues, Context, Output>(\n  schema: Struct<Input, any>,\n  schemaOptions?: Parameters<typeof validate>[2],\n  resolverOptions: {\n    raw?: boolean;\n  } = {},\n): Resolver<Input, Context, Input | Output> {\n  return (values: Input, _, options) => {\n    const result = validate(values, schema, schemaOptions);\n\n    if (result[0]) {\n      return {\n        values: {},\n        errors: toNestErrors(parseErrorSchema(result[0]), options),\n      };\n    }\n\n    options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n    return {\n      values: resolverOptions.raw ? Object.assign({}, values) : result[1],\n      errors: {},\n    };\n  };\n}\n"],"names":["superstructResolver","schema","schemaOptions","resolverOptions","values","_","options","result","validate","errors","toNestErrors","error","failures","reduce","previous","path","join","message","type","shouldUseNativeValidation","validateFieldsNatively","raw","Object","assign"],"mappings":"sHAgDgB,SAAAA,EACdC,EACAC,EACAC,EAEI,CAAE,GAEN,MAAO,CAACC,EAAeC,EAAGC,KACxB,MAAMC,EAASC,EAASJ,EAAQH,EAAQC,GAExC,OAAIK,EAAO,GACF,CACLH,OAAQ,CAAA,EACRK,OAAQC,GAzDUC,EAyDoBJ,EAAO,GAxD5CI,EAAMC,WAAWC,OACtB,CAACC,EAAUH,KACRG,EAASH,EAAMI,KAAKC,KAAK,MAAQ,CAChCC,QAASN,EAAMM,QACfC,KAAMP,EAAMO,QACRJ,EACR,KAkDsDR,KAItDA,EAAQa,2BAA6BC,EAAuB,GAAId,GAEzD,CACLF,OAAQD,EAAgBkB,IAAMC,OAAOC,OAAO,CAAA,EAAInB,GAAUG,EAAO,GACjEE,OAAQ,CAAA,IAjEd,IAA0BE,EAoE1B"}